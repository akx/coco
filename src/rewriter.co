# The Coco language has a good deal of optional syntax, implicit syntax,
# and shorthand syntax. This can greatly complicate a grammar and bloat
# the resulting parse table. Instead of making the parser handle it all, we take
# a series of passes over the token stream, using this **Rewriter** to convert
# shorthand into the unambiguous long form, add implicit indentation and
# parentheses, balance incorrect nestings, and generally clean things up.

# **Rewriter** is used by [Lexer](#lexer),
# directly against its internal array of tokens.

exports import {rewrite, able}

# Rewrite the token stream in multiple passes, one logical filter at
# a time. This could certainly be changed into a single pass through the
# stream, with a big ol' efficient switch, but it's much nicer to work with
# like this. The order of these passes matters--indentation must be
# corrected before implicit parentheses can be wrapped around blocks of code.

function rewrite
  removeTerminators      it
  transformParens        it
  addImplicitIndentation it
  tagPostfixConditionals it
  addImplicitParentheses it
  addImplicitBraces      it
  expandLiterals         it
  it

# - Dispatch leading terminators that would introduce ambiguity in the grammar.
# - Some blocks occur in the middle of expressions.
#   Remove their trailing terminators here to simplify things.
function removeTerminators tokens
  i = -1
  break unless that.0 is \TERMINATOR while tokens[++i]
  i and tokens.splice 0 i
  i = 1
  while tokens[++i]
    continue unless tokens[i-1]0 is \TERMINATOR
    that.=0
    tokens.splice i-1 1 if that of EXPR_END or
                           that of <[ ELSE CASE DEFAULT CATCH FINALLY ]>
  void

# - `CALL( )` => ` CALL( )CALL`
# - `( ) -> ` => `PARAM( )PARAM ->`
# - `FUNCTION ( ... )   ` => `FUNCTION CALL( )CALL`
# - `FUNCTION ( ... ) ->` => `FUNCTION PARAM( )PARAM ->`
function transformParens tokens
  stack = []
  for token, i of tokens
    switch token.0
    case \( \CALL(
      token.postfn = true if tokens[i-1]?0 is \FUNCTION
      stack.push token
    case \) \)CALL then if start = stack.pop()
      if start.0 is \CALL(
        token.0 =  \)CALL
      else if token.1 and tokens[i+1]?0 of <[ -> <- ]>
        start.0 = \PARAM(
        token.0 = \)PARAM
        ++i
      else if start.postfn
        start.0 = \CALL(
        token.0 = \)CALL
  void

# Tag postfix conditionals as such, so that we can parse them with a
# different precedence.
function tagPostfixConditionals tokens
  detectEnd tokens, i+1, ok, go if token.0 is \IF for token, i of tokens
  function ok -> it.0 of <[ TERMINATOR INDENT ]>
  function go -> token.0 = \POST_IF if it.0 is not \INDENT
  void

# Because our grammar is LALR(1), it can't handle some single-line
# expressions that lack ending delimiters. **Rewriter** adds the implicit
# blocks, so it doesn't need to. `)` can close a single-line block,
# but we need to make sure it's balanced.
function addImplicitIndentation tokens
  i = -1
  while token = tokens[++i]
    [tag] = token
    continue unless tag of <[ THEN -> ELSE DEFAULT TRY CATCH FINALLY ]>
    switch next = tokens[i+1]0
    case \IF then continue if tag is \ELSE
    case \INDENT \THEN
      tokens.splice i-- 1 if tag is \THEN
      continue
    indent = [\INDENT 0 token.2]; dedent = [\DEDENT 0]
    if tag is \THEN
      tokens.splice --i, 1 if tokens[i-1]?0 is \TERMINATOR
      tokens[i] = indent
    else
      tokens.splice ++i, 0 indent
    switch
    case next of <[ , DOT ]> then --i; fallthrough  # ->,
    case \, is tokens[i+2]?0 then go 0 i+=2; ++i    # -> 0,
    case next of <[ ( [ { ]> and                    # -> [0],
         \, is tokens[idx = 1 + indexOfPair tokens, i+1]?0
      go 0 idx; ++i
    default
      seenSwitch = false
      detectEnd tokens, i+1, ok, go
  function ok token, i
    switch token.0
    case \DEDENT        then true
    case \TERMINATOR    then token.1 is not \;
    case \, \DOT        then tokens[i-1]eol
    case \ELSE          then tag is \THEN
    case \CATCH         then tag is \TRY
    case \FINALLY       then tag of <[ TRY CATCH THEN ]>
    case \SWITCH        then not seenSwitch := true
    case \CASE \DEFAULT then not seenSwitch
  function go [] i
    prev = tokens[i-1]
    tokens.splice if prev.0 is \, then i-1 else i, 0, dedent <<< {prev.2}
  void

# Object literals may be written without braces for simple cases.
# Insert the missing braces here to aid the parser.
function addImplicitBraces tokens
  stack = []; i = -1
  while token = tokens[++i]
    unless \: is tag = token.0
      switch
      case tag of EXPR_START
        tag = \{ if tag is \INDENT and tokens[i-1]?0 is \{
        stack.push [tag, i]
      case tag of EXPR_END
        start = stack.pop()
      continue
    paren   = tokens[i-1]?0 is \)
    oneline = paren and tokens[start.1 - 1]?0 is \: or # a: (..):
              tokens[i-2]?0 is \:                      # a: b:
    continue unless oneline or stack[*-1]?0 is not \{
    stack.push [\{]
    idx  = if paren then start.1 else i-1
    idx -= 2 while tokens[idx-2]?0 is \COMMENT
    tokens.splice idx, 0 [\{ \{ token.2]
    detectEnd tokens, ++i+1, ok, go
  function ok token, i
    return true if token.1 is \; or \DEDENT is tag = token.0
    switch tag
    case \,          then break
    case \TERMINATOR then return true if oneline
    default return false
    t1 = tokens[i+1]?0
    t1 is not (if tag is \, then \TERMINATOR else \COMMENT) and
    \: is not tokens[if t1 is \( then 1 + indexOfPair tokens, i+1 else i+2]?0
  function go(token, i) -> tokens.splice i, 0 [\} '' token.2]
  void

# Methods may be optionally called without parentheses for simple cases.
# Insert the missing parentheses here to aid the parser.
function addImplicitParentheses tokens
  i = -1; brackets = []
  while token = tokens[++i]
    doblock = false
    if token.1 is \do and tokens[i+1]?0 is \INDENT
      endi = indexOfPair tokens, i+1
      if tokens[endi+1]0 is \TERMINATOR and tokens[endi+2]?0 is \WHILE
        token.0 = \DO
        tokens[endi+2]done = true
        tokens.splice endi+1 1
      else
        (token = tokens[1+ i])0 = \(
        (tpair = tokens[endi])0 = \)
        doblock = tokens.splice i, 1
    continue unless i
    [tag] = token; prev = tokens[i-1]
    # `f a; .m b` => `f(a).m(b)`
    if tag is \DOT
      tokens.splice --i, 1 if prev.0 is \TERMINATOR
      continue
    if tag is \[
      brackets.push prev.0 is \DOT
    if prev.0 is \]
      if brackets.pop() then prev.index = true else continue
    unless postfn = prev.0 is \FUNCTION
      continue unless prev.spaced and able tokens, i, true
    soak = prev.0 is \?
    if doblock
      token.0 = \CALL(; tpair.0 = \)CALL
      if soak
        tokens.splice i-1 1
        token.1 = \?(
      continue
    continue unless tag of ARG or tag is \+- and not token.spaced
    continue if postfn and tag of <[ PARAM( -> ]>
    if tag is \CREMENT
      continue if token.spaced or tokens[i+1]?0 not of CHAIN
    skipBlock = seenSwitch = false
    tokens.splice --i, 1 if soak
    tokens.splice i++, 0 [\CALL( if soak then \?( else \(, token.2]
    detectEnd tokens, i, ok, go
  function ok token, i
    return true if token.alias and token.1 of <[ && || ]>
    pre = tokens[i-1]
    switch token.0
    case \DOT then return pre.spaced or pre.0 is \DEDENT
    case \SWITCH                         then seenSwitch := true; fallthrough
    case \IF \CLASS \FUNCTION \LET \WITH then skipBlock  := true
    case \CASE
      if seenSwitch then skipBlock := true else return true
    case \INDENT
      return skipBlock := false if skipBlock
      return pre.0 not of <[
        { [ , -> : ELSE ASSIGN IMPORT UNARY DEFAULT TRY CATCH FINALLY HURL DO
      ]>
    case \WHILE
      return false if token.done
      fallthrough
    case <[ TERMINATOR POST_IF FOR BY TO ]>
      return pre.0 is not \,
    false
  function go(token, i) -> tokens.splice i, 0 [\)CALL '' tokens[i-1]2]
  void

# - Slip unary {pl,min}uses off signed numbers.
# - Expand number ranges.
# - Insert `->` between each `new`/`function` facing a block.
# - Insert `,` between each non-callable token facing an argument token.
function expandLiterals tokens
  i = -1
  while token = tokens[++i]
    switch token.0
    case \STRNUM
      if ~'-+'indexOf sig = (num = '' + token.1)charAt 0
        token.1 = num.slice 1
        tokens.splice i++ 0 [\+- sig, token.2]
      continue if token.callable
    case \RANGE
      ts = []; lno = token.2
      to = token.to - if token.op is \to then 0 else 1e-15
      for n from +token.1 to to by +token.by or 1
        if 32r200 < ts.push [\STRNUM n, lno] [\, \, lno]
          carp 'range limit exceeded' lno
      if ts.length then ts.pop() else carp 'empty range' lno
      tokens.splice i, 1 ...ts
      i += ts.length - 1
    case \INDENT
      if tokens[i-1]
        if that.1 is \new or that.0 is \FUNCTION
          tokens.splice i++ 0 [\-> '' token.2]
        else if that.0 is \LET
          tokens.splice i, 0 [\CALL( '' token.2] [\)CALL '' token.2]
          i += 2
      continue
    case \LITERAL \} \!? then break
    case \) \)CALL then continue if token.1
    case \]        then continue if token.index
    case \CREMENT  then continue unless i and able tokens, i
    default continue
    if token.spaced and tokens[i+1]0 of ARG
      tokens.splice ++i, 0 [\, \, token.2]
  void

### Helpers

# Seeks `tokens` from index `i` for a token of the same level matching `ok`,
# then calls `go`.
function detectEnd tokens, i, ok, go
  levels = 0
  while token = tokens[i]
    if      not levels then return go token, i if ok token, i
    else if 0 > levels then return go token, i-1
    [tag] = token
    if      tag of EXPR_START then ++levels
    else if tag of EXPR_END   then --levels
    ++i
  void

# Checks whether or not the previous token is {index,`call`}able.
function able tokens, i ? tokens.length, call
  [tag] = token = tokens[i-1]
  tag of <[ ID ] SUPER ]> or if call
  then token.callable or tag of <[ ? LET ]> or tag of <[ ) )CALL ]> and token.1
  else tag of <[ STRNUM LITERAL ) )CALL } ]>

function indexOfPair tokens, i
  level = 1; end = INVERSES[start = tokens[i]0]
  while tokens[++i]
    switch that.0
    case start then ++level
    case end   then return i unless --level
  -1

function carp(msg, lno) -> throw SyntaxError "#{msg} on line #{-~lno}"

### Constants

# List of the token pairs that must be balanced.
BALANCED_PAIRS =
  <[      ( )      ]>
  <[      [ ]      ]>
  <[      { }      ]>
  <[  CALL( )CALL  ]>
  <[ PARAM( )PARAM ]>
  <[ INDENT DEDENT ]>

# The inverse mappings of `BALANCED_PAIRS` to look things up from either end.
INVERSES = {}

# Tokens that signal the start/end of a balanced pair.
EXPR_START = []
EXPR_END   = []

for [left, rite] of BALANCED_PAIRS
  EXPR_START.push INVERSES[rite] = left
  EXPR_END  .push INVERSES[left] = rite

# Tokens that can start a dot/call chain.
CHAIN = <[ ( { [ ID STRNUM LITERAL LET WITH ]>

# Tokens that can start an argument list.
ARG = CHAIN.concat <[ -> ... UNARY CREMENT PARAM( FUNCTION
                      IF SWITCH TRY CLASS SUPER RANGE LABEL DO ]>
